#!/usr/bin/env swift

import Foundation

// This script validates that all data models and protocols are correctly implemented
// according to the requirements in task 2

print("üîç Validating Task 2: Data Models and Protocol Definitions")
print("=========================================================")

var testsPassed = 0
var testsFailed = 0

func runTest(_ testName: String, _ testBlock: () throws -> Void) {
    do {
        try testBlock()
        print("‚úÖ \(testName)")
        testsPassed += 1
    } catch {
        print("‚ùå \(testName): \(error)")
        testsFailed += 1
    }
}

// Test 1: JMSConfig data model
print("\nüìã Testing JMSConfig Data Model")
print("--------------------------------")

runTest("JMSConfig initialization") {
    let config = JMSConfig(
        filename: "test.rdp",
        protocol: "rdp", 
        username: "testuser",
        token: "testtoken",
        config: "full address:s:test.com:3389"
    )
    
    guard config.filename == "test.rdp" else {
        throw TestError.assertionFailed("filename mismatch")
    }
    guard config.protocol == "rdp" else {
        throw TestError.assertionFailed("protocol mismatch")
    }
    guard config.username == "testuser" else {
        throw TestError.assertionFailed("username mismatch")
    }
}

runTest("JMSConfig JSON encoding/decoding") {
    let originalConfig = JMSConfig(
        filename: "test.rdp",
        protocol: "rdp",
        username: "testuser", 
        token: "testtoken",
        config: "full address:s:test.com:3389"
    )
    
    let jsonData = try JSONEncoder().encode(originalConfig)
    let decodedConfig = try JSONDecoder().decode(JMSConfig.self, from: jsonData)
    
    guard decodedConfig.filename == originalConfig.filename else {
        throw TestError.assertionFailed("decoded filename mismatch")
    }
    guard decodedConfig.protocol == originalConfig.protocol else {
        throw TestError.assertionFailed("decoded protocol mismatch")
    }
}

runTest("JMSConfig validation - valid config") {
    let validConfig = JMSConfig(
        filename: "test.rdp",
        protocol: "rdp",
        username: "testuser",
        token: "testtoken", 
        config: "full address:s:test.com:3389"
    )
    
    try validConfig.validate()
}

runTest("JMSConfig validation - missing filename") {
    let invalidConfig = JMSConfig(
        filename: "",
        protocol: "rdp",
        username: "testuser",
        token: "testtoken",
        config: "full address:s:test.com:3389"
    )
    
    do {
        try invalidConfig.validate()
        throw TestError.assertionFailed("Should have thrown error for missing filename")
    } catch JMSError.missingRequiredField(let field) {
        guard field == "filename" else {
            throw TestError.assertionFailed("Wrong field in error: \(field)")
        }
    }
}

runTest("JMSConfig isRDPProtocol property") {
    let rdpConfig = JMSConfig(filename: "test.rdp", protocol: "rdp", username: "user", token: "token", config: "config")
    let sshConfig = JMSConfig(filename: "test.ssh", protocol: "ssh", username: "user", token: "token", config: "config")
    
    guard rdpConfig.isRDPProtocol == true else {
        throw TestError.assertionFailed("RDP config should return true")
    }
    guard sshConfig.isRDPProtocol == false else {
        throw TestError.assertionFailed("SSH config should return false")
    }
}

// Test 2: ConnectionInfo data model
print("\nüîó Testing ConnectionInfo Data Model")
print("------------------------------------")

runTest("ConnectionInfo initialization") {
    let connectionInfo = ConnectionInfo(
        fullAddress: "test.com:3389",
        username: "testuser",
        sessionBpp: 32,
        audioMode: 0,
        smartSizing: true,
        screenModeId: 2,
        additionalConfig: ["custom": "value"]
    )
    
    guard connectionInfo.fullAddress == "test.com:3389" else {
        throw TestError.assertionFailed("fullAddress mismatch")
    }
    guard connectionInfo.username == "testuser" else {
        throw TestError.assertionFailed("username mismatch")
    }
    guard connectionInfo.sessionBpp == 32 else {
        throw TestError.assertionFailed("sessionBpp mismatch")
    }
}

runTest("ConnectionInfo validation - valid info") {
    let validInfo = ConnectionInfo(fullAddress: "test.com:3389", username: "testuser")
    try validInfo.validate()
}

runTest("ConnectionInfo validation - empty address") {
    let invalidInfo = ConnectionInfo(fullAddress: "", username: "testuser")
    
    do {
        try invalidInfo.validate()
        throw TestError.assertionFailed("Should have thrown error for empty address")
    } catch JMSError.missingConnectionInfo {
        // Expected error
    }
}

runTest("ConnectionInfo hostname extraction") {
    let info1 = ConnectionInfo(fullAddress: "test.com:3389", username: "user")
    let info2 = ConnectionInfo(fullAddress: "test.com", username: "user")
    
    guard info1.hostname == "test.com" else {
        throw TestError.assertionFailed("hostname extraction failed for address with port")
    }
    guard info2.hostname == "test.com" else {
        throw TestError.assertionFailed("hostname extraction failed for address without port")
    }
}

runTest("ConnectionInfo port extraction") {
    let info1 = ConnectionInfo(fullAddress: "test.com:3390", username: "user")
    let info2 = ConnectionInfo(fullAddress: "test.com", username: "user")
    
    guard info1.port == 3390 else {
        throw TestError.assertionFailed("port extraction failed: expected 3390, got \(info1.port)")
    }
    guard info2.port == 3389 else {
        throw TestError.assertionFailed("default port failed: expected 3389, got \(info2.port)")
    }
}

runTest("ConnectionInfo RDP content generation") {
    let info = ConnectionInfo(
        fullAddress: "test.com:3389",
        username: "testuser",
        sessionBpp: 32,
        audioMode: 0,
        smartSizing: true,
        screenModeId: 2
    )
    
    let rdpContent = info.generateRDPContent()
    
    guard rdpContent.contains("full address:s:test.com:3389") else {
        throw TestError.assertionFailed("RDP content missing full address")
    }
    guard rdpContent.contains("username:s:testuser") else {
        throw TestError.assertionFailed("RDP content missing username")
    }
    guard rdpContent.contains("session bpp:i:32") else {
        throw TestError.assertionFailed("RDP content missing session bpp")
    }
    guard rdpContent.contains("smart sizing:i:1") else {
        throw TestError.assertionFailed("RDP content missing smart sizing")
    }
}

// Test 3: JMSURLComponents data model
print("\nüîó Testing JMSURLComponents Data Model")
print("--------------------------------------")

runTest("JMSURLComponents initialization") {
    let components = JMSURLComponents(
        scheme: "jms",
        encodedPayload: "eyJ0ZXN0IjoidmFsdWUifQ==",
        originalURL: URL(string: "jms://eyJ0ZXN0IjoidmFsdWUifQ==")
    )
    
    guard components.scheme == "jms" else {
        throw TestError.assertionFailed("scheme mismatch")
    }
    guard components.encodedPayload == "eyJ0ZXN0IjoidmFsdWUifQ==" else {
        throw TestError.assertionFailed("encodedPayload mismatch")
    }
}

runTest("JMSURLComponents validation - valid components") {
    let validComponents = JMSURLComponents(scheme: "jms", encodedPayload: "eyJ0ZXN0IjoidmFsdWUifQ==")
    try validComponents.validate()
}

runTest("JMSURLComponents validation - invalid scheme") {
    let invalidComponents = JMSURLComponents(scheme: "http", encodedPayload: "eyJ0ZXN0IjoidmFsdWUifQ==")
    
    do {
        try invalidComponents.validate()
        throw TestError.assertionFailed("Should have thrown error for invalid scheme")
    } catch JMSError.invalidURL {
        // Expected error
    }
}

runTest("JMSURLComponents validation - empty payload") {
    let invalidComponents = JMSURLComponents(scheme: "jms", encodedPayload: "")
    
    do {
        try invalidComponents.validate()
        throw TestError.assertionFailed("Should have thrown error for empty payload")
    } catch JMSError.invalidURL {
        // Expected error
    }
}

// Test 4: JMSError enum
print("\n‚ö†Ô∏è  Testing JMSError Enum")
print("------------------------")

runTest("JMSError error descriptions") {
    let errors: [(JMSError, String)] = [
        (.invalidURL, "URLÊ†ºÂºèÈîôËØØ"),
        (.decodingFailed, "Ëß£Á†ÅÂ§±Ë¥•"),
        (.jsonParsingFailed, "ÈÖçÁΩÆ‰ø°ÊÅØÊ†ºÂºèÈîôËØØ"),
        (.missingConnectionInfo, "ËøûÊé•‰ø°ÊÅØ‰∏çÂÆåÊï¥"),
        (.remoteDesktopNotFound, "Êú™ÊâæÂà∞Microsoft Remote DesktopÂ∫îÁî®Á®ãÂ∫è"),
        (.remoteDesktopLaunchFailed, "ÂêØÂä®Microsoft Remote DesktopÂ§±Ë¥•"),
        (.configParsingFailed, "ÈÖçÁΩÆËß£ÊûêÂ§±Ë¥•"),
        (.missingRequiredField("test"), "Áº∫Â∞ëÂøÖË¶ÅÂ≠óÊÆµ: test")
    ]
    
    for (error, expectedDescription) in errors {
        guard error.errorDescription == expectedDescription else {
            throw TestError.assertionFailed("Error description mismatch for \(error)")
        }
    }
}

runTest("JMSError failure reasons") {
    let error = JMSError.invalidURL
    guard error.failureReason != nil else {
        throw TestError.assertionFailed("Failure reason should not be nil")
    }
}

runTest("JMSError recovery suggestions") {
    let error = JMSError.remoteDesktopNotFound
    guard error.recoverySuggestion != nil else {
        throw TestError.assertionFailed("Recovery suggestion should not be nil")
    }
}

// Test 5: Protocol definitions exist (basic check)
print("\nüìã Testing Protocol Definitions")
print("-------------------------------")

runTest("Protocol files exist") {
    let protocolFiles = [
        "JMSProtocolHandler/JMSProtocolHandler/Protocols/URLParserProtocol.swift",
        "JMSProtocolHandler/JMSProtocolHandler/Protocols/PayloadDecoderProtocol.swift", 
        "JMSProtocolHandler/JMSProtocolHandler/Protocols/ConnectionInfoExtractorProtocol.swift",
        "JMSProtocolHandler/JMSProtocolHandler/Protocols/ErrorHandlerProtocol.swift",
        "JMSProtocolHandler/JMSProtocolHandler/Protocols/RemoteDesktopIntegratorProtocol.swift"
    ]
    
    for file in protocolFiles {
        guard FileManager.default.fileExists(atPath: file) else {
            throw TestError.assertionFailed("Protocol file missing: \(file)")
        }
    }
}

// Summary
print("\nüìä Test Summary")
print("===============")
print("‚úÖ Tests Passed: \(testsPassed)")
print("‚ùå Tests Failed: \(testsFailed)")
print("üìà Success Rate: \(testsPassed)/\(testsPassed + testsFailed) (\(Int(Double(testsPassed)/Double(testsPassed + testsFailed) * 100))%)")

if testsFailed == 0 {
    print("\nüéâ All tests passed! Task 2 implementation is complete and working correctly.")
    print("\n‚úÖ Task 2 Requirements Verification:")
    print("   ‚úì ÂàõÂª∫JMSConfig„ÄÅConnectionInfoÁ≠âÊ†∏ÂøÉÊï∞ÊçÆÁªìÊûÑ")
    print("   ‚úì ÂÆö‰πâÂêÑ‰∏™Ê®°ÂùóÁöÑÂçèËÆÆÊé•Âè£")
    print("   ‚úì ÂÆûÁé∞JMSErrorÈîôËØØÊûö‰∏æÂíåÈîôËØØÂ§ÑÁêÜÂçèËÆÆ")
    print("   ‚úì ÁºñÂÜôÊï∞ÊçÆÊ®°ÂûãÁöÑÂçïÂÖÉÊµãËØï")
} else {
    print("\n‚ö†Ô∏è  Some tests failed. Please review the implementation.")
    exit(1)
}

// Supporting types and models for testing
enum TestError: Error {
    case assertionFailed(String)
}

struct JMSConfig: Codable {
    let filename: String
    let `protocol`: String
    let username: String
    let token: String
    let config: String
    
    enum CodingKeys: String, CodingKey {
        case filename, `protocol`, username, token, config
    }
    
    func validate() throws {
        if filename.isEmpty {
            throw JMSError.missingRequiredField("filename")
        }
        if `protocol`.isEmpty {
            throw JMSError.missingRequiredField("protocol")
        }
        if username.isEmpty {
            throw JMSError.missingRequiredField("username")
        }
        if token.isEmpty {
            throw JMSError.missingRequiredField("token")
        }
        if config.isEmpty {
            throw JMSError.missingRequiredField("config")
        }
    }
    
    var isRDPProtocol: Bool {
        return `protocol`.lowercased() == "rdp"
    }
}

struct ConnectionInfo {
    let fullAddress: String
    let username: String
    let sessionBpp: Int?
    let audioMode: Int?
    let smartSizing: Bool?
    let screenModeId: Int?
    let additionalConfig: [String: String]
    
    init(fullAddress: String, username: String, sessionBpp: Int? = nil, 
         audioMode: Int? = nil, smartSizing: Bool? = nil, 
         screenModeId: Int? = nil, additionalConfig: [String: String] = [:]) {
        self.fullAddress = fullAddress
        self.username = username
        self.sessionBpp = sessionBpp
        self.audioMode = audioMode
        self.smartSizing = smartSizing
        self.screenModeId = screenModeId
        self.additionalConfig = additionalConfig
    }
    
    func validate() throws {
        guard !fullAddress.isEmpty else {
            throw JMSError.missingConnectionInfo
        }
        guard !username.isEmpty else {
            throw JMSError.missingConnectionInfo
        }
    }
    
    var hostname: String {
        return fullAddress.components(separatedBy: ":").first ?? fullAddress
    }
    
    var port: Int {
        let components = fullAddress.components(separatedBy: ":")
        if components.count > 1, let port = Int(components[1]) {
            return port
        }
        return 3389
    }
    
    func generateRDPContent() -> String {
        var rdpContent = [
            "full address:s:\(fullAddress)",
            "username:s:\(username)"
        ]
        
        if let sessionBpp = sessionBpp {
            rdpContent.append("session bpp:i:\(sessionBpp)")
        }
        
        if let audioMode = audioMode {
            rdpContent.append("audiomode:i:\(audioMode)")
        }
        
        if let smartSizing = smartSizing {
            rdpContent.append("smart sizing:i:\(smartSizing ? 1 : 0)")
        }
        
        if let screenModeId = screenModeId {
            rdpContent.append("screen mode id:i:\(screenModeId)")
        }
        
        for (key, value) in additionalConfig {
            rdpContent.append("\(key):\(value)")
        }
        
        return rdpContent.joined(separator: "\n")
    }
}

struct JMSURLComponents {
    let scheme: String
    let encodedPayload: String
    let originalURL: URL?
    
    init(scheme: String, encodedPayload: String, originalURL: URL? = nil) {
        self.scheme = scheme
        self.encodedPayload = encodedPayload
        self.originalURL = originalURL
    }
    
    func validate() throws {
        guard scheme.lowercased() == "jms" else {
            throw JMSError.invalidURL
        }
        guard !encodedPayload.isEmpty else {
            throw JMSError.invalidURL
        }
    }
}

enum JMSError: LocalizedError {
    case invalidURL
    case decodingFailed
    case jsonParsingFailed
    case missingConnectionInfo
    case remoteDesktopNotFound
    case remoteDesktopLaunchFailed
    case configParsingFailed
    case missingRequiredField(String)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "URLÊ†ºÂºèÈîôËØØ"
        case .decodingFailed:
            return "Ëß£Á†ÅÂ§±Ë¥•"
        case .jsonParsingFailed:
            return "ÈÖçÁΩÆ‰ø°ÊÅØÊ†ºÂºèÈîôËØØ"
        case .missingConnectionInfo:
            return "ËøûÊé•‰ø°ÊÅØ‰∏çÂÆåÊï¥"
        case .remoteDesktopNotFound:
            return "Êú™ÊâæÂà∞Microsoft Remote DesktopÂ∫îÁî®Á®ãÂ∫è"
        case .remoteDesktopLaunchFailed:
            return "ÂêØÂä®Microsoft Remote DesktopÂ§±Ë¥•"
        case .configParsingFailed:
            return "ÈÖçÁΩÆËß£ÊûêÂ§±Ë¥•"
        case .missingRequiredField(let field):
            return "Áº∫Â∞ëÂøÖË¶ÅÂ≠óÊÆµ: \(field)"
        }
    }
    
    var failureReason: String? {
        switch self {
        case .invalidURL:
            return "Êèê‰æõÁöÑURL‰∏çÊòØÊúâÊïàÁöÑjms://ÂçèËÆÆÊ†ºÂºè"
        case .decodingFailed:
            return "Êó†Ê≥ïÂØπbase64ÁºñÁ†ÅÁöÑÂÜÖÂÆπËøõË°åËß£Á†Å"
        case .jsonParsingFailed:
            return "JSONÈÖçÁΩÆ‰ø°ÊÅØÊ†ºÂºè‰∏çÊ≠£Á°ÆÊàñÂåÖÂê´Êó†ÊïàÊï∞ÊçÆ"
        case .missingConnectionInfo:
            return "ÈÖçÁΩÆ‰∏≠Áº∫Â∞ëÂøÖË¶ÅÁöÑËøûÊé•‰ø°ÊÅØ"
        case .remoteDesktopNotFound:
            return "Á≥ªÁªü‰∏≠Êú™ÂÆâË£ÖMicrosoft Remote DesktopÂ∫îÁî®Á®ãÂ∫è"
        case .remoteDesktopLaunchFailed:
            return "Êó†Ê≥ïÂêØÂä®Microsoft Remote DesktopÂ∫îÁî®Á®ãÂ∫è"
        case .configParsingFailed:
            return "Êó†Ê≥ïËß£ÊûêÈÖçÁΩÆÂ≠óÁ¨¶‰∏≤‰∏≠ÁöÑÂèÇÊï∞"
        case .missingRequiredField(let field):
            return "ÈÖçÁΩÆ‰∏≠Áº∫Â∞ëÂøÖË¶ÅÁöÑÂ≠óÊÆµ: \(field)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .invalidURL:
            return "ËØ∑Ê£ÄÊü•URLÊ†ºÂºèÊòØÂê¶Ê≠£Á°ÆÔºåÁ°Æ‰øù‰ª•jms://ÂºÄÂ§¥"
        case .decodingFailed:
            return "ËØ∑Ê£ÄÊü•URL‰∏≠ÁöÑÁºñÁ†ÅÂÜÖÂÆπÊòØÂê¶‰∏∫ÊúâÊïàÁöÑbase64Ê†ºÂºè"
        case .jsonParsingFailed:
            return "ËØ∑Ê£ÄÊü•ÈÖçÁΩÆ‰ø°ÊÅØÊòØÂê¶‰∏∫ÊúâÊïàÁöÑJSONÊ†ºÂºè"
        case .missingConnectionInfo:
            return "ËØ∑Á°Æ‰øùÈÖçÁΩÆ‰∏≠ÂåÖÂê´ÂÆåÊï¥ÁöÑËøûÊé•‰ø°ÊÅØ"
        case .remoteDesktopNotFound:
            return "ËØ∑‰ªéMac App StoreÂÆâË£ÖMicrosoft Remote DesktopÂ∫îÁî®Á®ãÂ∫è"
        case .remoteDesktopLaunchFailed:
            return "ËØ∑Ê£ÄÊü•Microsoft Remote DesktopÊòØÂê¶Ê≠£Á°ÆÂÆâË£ÖÂπ∂ÂèØ‰ª•Ê≠£Â∏∏ÂêØÂä®"
        case .configParsingFailed:
            return "ËØ∑Ê£ÄÊü•ÈÖçÁΩÆÂ≠óÁ¨¶‰∏≤Ê†ºÂºèÊòØÂê¶Ê≠£Á°Æ"
        case .missingRequiredField:
            return "ËØ∑Á°Æ‰øùÈÖçÁΩÆÂåÖÂê´ÊâÄÊúâÂøÖË¶ÅÁöÑÂ≠óÊÆµ"
        }
    }
}